name: Deploy website
on:
  push:
    branches:
      - master
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Cache dependencies
#This step caches npm dependencies
        #~/.npm folder is stored
        #Cache key depends on package-lock.json
        #Speeds up workflow execution
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        run: npm ci
      - name: Lint code
        run: npm run lint
      - name: Test code
        run: npm run test
  build:
    needs: test
    runs-on: ubuntu-latest
#Here, the build job defines its job-level output using the step’s output (publish)
    #So needs.build.outputs.script-file in the deploy job can access it
    outputs:
      script-file: ${{steps.publish.outputs.script-file }}
    steps:
      - name: Get code
        uses: actions/checkout@v3
#uses: actions/cache@v4
      #This is a GitHub Action that caches files or folders between workflow runs.
      #It speeds up builds by reusing previously downloaded dependencies instead of installing them again.
#path: ~/.npm
      #Specifies what to cache.
      #~/.npm → the folder where npm stores downloaded packages.
#key: deps-node-modules-{{ hashFiles('**/package-lock.jason') }}
      #key is how GitHub identifies your cache.
      #It combines a prefix (deps-node-modules-) + hash of a file:
#Short Summary
      #actions/cache → saves files/folders between runs
      #
      #path → folder to cache (~/.npm)
      #
      #key → unique identifier, usually includes hash of lock file
      #
      #Speeds up builds and avoids reinstalling dependencies
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: deps-node-modules-${{ hashFiles('**/package-lock.jason') }}
      - name: Install dependencies
        run: npm ci
      - name: Build website
        run: npm run build
      - name: Publish js filename
        id: publish
#Finds all JS files in dist/assets/
        #For each file, it writes an output variable called script-file to GitHub’s environment output file ($GITHUB_OUTPUT)
        #This sets the output for the step with id: publish
        #Example: If dist/assets/ has main.js and vendor.js, the loop runs twice, but only the last file will be stored in step output because script-file is overwritten in each iteration.
        run: |
              for file in dist/assets/*.js; do
                echo "script-file=$file" >> $GITHUB_OUTPUT
              done
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path:
            dist
#            package.json
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Git Build artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist-files
      - name: dist-file-read
        run: ls
#Prints the file name set by the publish step
      #
      #Only prints the last JS file found because the loop overwrote script-file each time
      - name: Output  file name from top
        run: echo "${{ needs.build.outputs.script-file }}"
      - name: Deploy
        run: echo "Deploying..."

#4. How it worked
#
#Build job runs → JS files are listed in dist/assets
#
#Loop sets step output using $GITHUB_OUTPUT
#
#Build job exposes step output as job output
#
#Deploy job accesses it using needs.build.outputs → prints the last file name

#Short Summary
#
#The workflow finds JS files in dist/assets
#
#Sets the last file found as a step output (publish)
#
#Exposes it as job output (build)
#
#The deploy job prints it using needs.build.outputs.script-file
#
#Output = last JS file in folder unless you join multiple files.
